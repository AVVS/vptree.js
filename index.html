<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Vptree.js by fpirsch</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Vptree.js</h1>
        <h2>JavaScript implementation of the Vantage-Point Tree nearest neighbor search algorithm</h2>
        <a href="https://github.com/fpirsch/vptree.js" class="button"><small>View project on</small>GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h3><a name="vp-tree" class="anchor" href="#vp-tree"><span class="octicon octicon-link"></span></a>Vantage-point tree</h3>

			<p>
			A <a href="https://en.wikipedia.org/wiki/Vantage-point_tree">vantage-point tree</a> is a special case of
			<a href="https://en.wikipedia.org/wiki/Metric_trees">metric tree</a>, a space-partitioning data structure used by
			efficient <a href="https://en.wikipedia.org/wiki/Nearest_neighbor_search">nearest neighbor search</a> algorithms.
			</p>

			<p>
			If you are in Mexico, looking for the nearest sushi bar in the giant World Sushi Bar Database, you can ignore those that are known to be less than 1000 km
			away from Kuala Lumpur. That's what the vp-tree does : group together items that are close to a particular one (here Kuala Lumpur is the vantage point),
			so that the whole group can easily be skipped in the search phase.
			</p>



			<h3><a name="advantages" class="anchor" href="#advantages"><span class="octicon octicon-link"></span></a>Advantages</h3>

			<p>
			To construct the vp-tree, a particular item (the vantage-point) is chosen in the initial dataset. The other items are then divided into two <code>near</code>
			and <code>far</code> subsets, which are recursively subdivided the same way.<br>
			The search algorithm exploits the <a href="https://en.wikipedia.org/wiki/Triangle_inequality">triangle inequality</a> to exclude large portions of the tree
			that are too far from the query object.
			</p>

			<p>
			One of the great things about this method is that it applies to any kind of objects. Not only sushi bars but also DNA sequences, images, faces. You only
			need a function to measure the similarity between two objects, and this is not limited to the standard
			<a href="https://en.wikipedia.org/wiki/Euclidean_distance">euclidean distance</a>. Any metric, i.e. any distance function which satisfies
			<a href="https://en.wikipedia.org/wiki/Metric_space#Definition">these conditions</a> can be used. Here are
			<a href="https://en.wikipedia.org/wiki/Metric_space#Examples_of_metric_spaces">a few examples of distances</a>.
			</p>



			<h3><a name="demo" class="anchor" href="#demo"><span class="octicon octicon-link"></span></a>Demo</h3>

			<figure class="float-left">
				<a href="search-cities"><img src="images/search-cities-thumb.png" width="266" height="150" border="0" alt="Search cities"></a>
			</figure>

			<h4 class="right">Search nearest cities by coordinates</h4>

			<p class="right">
			Enter geographic coordinates, and find the k-nearest cities in a list of more than 50 thousands of cities, instantly.
			</p>

			<div class="clearfix"></div>


			<h3><a name="string-matching" class="anchor" href="#string-matching"><span class="octicon octicon-link"></span></a>About fuzzy string matching</h3>

			<p>
			Some <a href="https://en.wikipedia.org/wiki/String_metric">string metrics</a> may not be very good candidates to use with vp-trees.
			Common ones like the <a href="https://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein distance</a> or the
			<a href="https://en.wikipedia.org/wiki/Damerau%E2%80%93Levenshtein_distance">Damerau-Levenshtein distance</a> only take small integer
			values. Even if they are metrics per se and can in theory be used to build vp-trees, the resulting trees won't be very efficient.
			To get the most of a vp-tree you need the distances between items to spread over a wide range of different value.
			</p>

        </section>

        <aside id="sidebar">
          <a href="https://github.com/fpirsch/vptree.js/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/fpirsch/vptree.js/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/fpirsch/vptree.js">vptree.js</a> is maintained by <a href="https://github.com/fpirsch">fpirsch</a>.</p>

          <p>This page was generated by <a href="pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>